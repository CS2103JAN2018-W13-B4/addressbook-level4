= PrioriTask - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
:repoURL: https://github.com/CS2103JAN2018-W13-B4/main

By: `CS2103JAN2018-W13-B4`      Since: `March 2018`      Licence: `MIT`

== Introduction

PrioriTask is a desktop task management application. It is not just any task management application, but a combination of the to-do list, calendar and reminder features, with an added bonus of an automatic updating and sorting of your tasks based on priority levels. It helps you keep track of your tasks, while providing you with at-a-glance views of upcoming tasks by day, week or month.

PrioriTask is a fairly new application that has much room for improvement. We welcome any form of contributions to the PrioriTask project, be it from beginners or seasoned Java developers. Whether you're a new developer or an experienced contributor, this guide can serve as a helpful reference and source for information about writing code for the PrioriTask project.

This developer's guide consists of the following sections.

* <<Getting Started>>
* <<Design>>
* <<Implementation>>
* <<Documentation>>
* <<Testing>>
* <<Dev Ops>>

== Getting Started

This section contains information to help you get started developing for PrioriTask. The simple list below will ensure that you get up and running with the application in no time.

* <<Installing prerequisites>>
* <<Setting up the project in your computer>>
* <<Verifying the setup>>
* <<Configuring the project before writing code>>

=== Installing prerequisites

Before working on PrioriTask, ensure that you have the following software installed.

. *JDK `1.8.0_60`* or later
+
[NOTE]
PrioriTask works best on JDK `1.8.0_60` or later. +
It will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
PrioriTask requires Gradle and JavaFX plugins. +
IntelliJ has both plugins installed by default. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.

=== Setting up the project in your computer

After you've ensured that you've met all requirements, follow the steps below to setup this project in your computer.

[NOTE]
The following steps are written for IntelliJ IDEA `2017.3.5` (Ultimate Edition). +
There may be slight variations in the steps if using other versions of IntelliJ.

. Fork this repo, and clone the fork to your computer.
. Open IntelliJ. You should see the welcome screen (refer to Figure 1). If you do not see the welcome screen, select `File` > `Close Project` to close the existing project dialog first.

.IntelliJ's Welcome Screen
image::DeveloperGettingStarted1.png[width="600"]

[start=3]
. Click on `Import Project`.
. Locate the cloned folder, and select it. Click `OK`. You will be directed to the `Import Project` window (refer to Figure 2).

.The first page of the `Import Project` window.
image::DeveloperGettingStarted2.png[width="600"]

[start=5]
. Check the `Create project from existing sources` box and click `Next`. You will be directed to the next window (refer to Figure 3).

.The second page of the `Import Project` window.
image::DeveloperGettingStarted3.png[width="600"]

[start=6]
. Fill up the necessary information as follows, and click `Next`. You will be directed to the next window.
. Click `Next` until to reach the window to select the project SDK (refer to Figure 4).

.`Import Project` window: Select Project SDK
image::DeveloperGettingStarted4.png[width="600"]

[start=8]
. Click on the JDK `1.8` folder in the left pane and click `Next`. If you do not see a JDK `1.8` folder, click on `+` > `JDK`, and find the directory of the JDK.
. Click `Next` until you reach the last window. Click `Finish` to complete the import of the project. The project will be loaded and you will be brought to the main project window (refer to Figure 5).

.Main Project Window
image::DeveloperGettingStarted5.png[width="600"]

[start=10]
. Select `File` > `New` > `Module from Existing Sources...`.
. Locate the `build.gradle` file and select it. Click `OK`. You will be directed to the `Import Module from Gradle` window (refer to Figure 6).

.`Import Module from Gradle` Window
image::DeveloperGettingStarted6.png[width="600"]

. Click `OK` to accept the default settings.
. Open the `Terminal` (select `Tool Windows` > `Terminal`) and run the command `gradlew processResources` (run `./gradlew processResources` for Mac/Linux users). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

After setting up the project, do the following steps to verify that the project has been correctly set up.

. Run the `seedu.organizer.MainApp` and try a few commands. You may refer to the <<UserGuide#, UserGuide.adoc>> for more information about the commands.
. <<Testing,Run the tests>> to ensure they all pass.

=== Configuring the project before writing code

Before you begin developing, there are a few configurations to be done to ensure that the code you write meets our project standards. 

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (Mac).
. Select `Editor` > `Code Style` > `Java`.
. Click on the `Imports` tab to set the order.

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements.
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`.

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write the code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `CS2103JAN2018-W13-B4/main` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `CS2103JAN2018-W13-B4/main`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

This project relies heavily on Travis to perform Continuous Integration (CI). You may also set up Travis for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version, but is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures the application works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based).

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading <<Design-Architecture>>.
2. Take a look at <<GetStartedProgramming>>.

== Design

_{ Preface to be added. }_

[[Design-Architecture]]
=== Architecture

The *_Architecture Diagram_* (refer to Figure 1) given below explains the high-level design of the App.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

.Architecture Diagram
image::Architecture.png[width="600"]

Given below is a quick overview of each component. The two main components of the App includes:

. `Main`, with only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

.. Initializing the components in the correct sequence, and connecting them up with each other at app launch.
.. Shutting down the components and invokes cleanup method where necessary during shut down.

. <<Design-Commons,*`Commons`*>>, representing a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

.. `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design).
.. `LogsCenter` : This class is used by many classes to write log messages to the App's log file.

The rest of the App consists of four components:

. <<Design-Ui,*`UI`*>>: Represents the UI of the App
. <<Design-Logic,*`Logic`*>>: Executes commands
. <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
. <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (refer to Figure 2) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeleteTask.png[width="800"]

[NOTE]
Note how the `Model` simply raises a `OrganizerChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeleteTaskEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/organizer/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `TaskListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

.Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in <<fig-LogicClassDiagram>>
image::LogicCommandClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/organizer/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `OrganizerParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a task) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteTaskSdForLogic.png[width="800"]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/organizer/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Organizer data.
* automatically updates Tasks' priority levels within the Organizer via the UniqueTaskList
* sorts tasks within the Organizer
* exposes an unmodifiable `ObservableList<Task>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/organizer/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Organizer data in xml format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.organizer.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the organizer (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

.Reference from Figure 7.
image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

===== Scenario

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th task in the organizer. The current state of the organizer is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

.UndoRedoStack `delete 5` command execution
image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/Study ...` to add a new task.

.UndoRedoStack `add n/Study ...` command execution
image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the task was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the organizer to the state before the `add` command executed.

.UndoRedoStack `undo` command execution
image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

.UndeRedoStack sequence diagram
image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the organizer to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/Study` command (this is the behavior that most modern desktop applications follow).

.UndoRedoStack `clear` command execution
image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

.UndoRedoStack `list` command execution
image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

.UndoRedoStack activity diagram
image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: Implementation of `UndoableCommand`

* **Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()`
** Pros: We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist.
** Cons: Hard for new developers to understand the template pattern.
* **Alternative 2:** Just override `execute()`
** Pros: Does not involve the template pattern, easier for new developers to understand.
** Cons: Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire organizer.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the task being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.


===== Aspect: Type of commands that can be undone/redone

* **Alternative 1 (current choice):** Only include commands that modifies the organizer (`add`, `clear`, `edit`).
** Pros: We only revert changes that are hard to change back (the view can easily be re-modified as no data are * lost).
** Cons: User might think that undo also applies when the list is modified (undoing filtering for example), * only to realize that it does not do that, after executing `undo`.
* **Alternative 2:** Include all commands.
** Pros: Might be more intuitive for the user.
** Cons: User have no way of skipping such commands if he or she just want to reset the state of the organizer and not the view.
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use separate stack for undo and redo
** Pros: Easy to understand for new Computer Science student undergraduates to understand, who are likely to be * the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update * both `HistoryManager` and `UndoRedoStack`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate stack, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two * different things.
// end::undoredo[]

// tag::taskpriority[]
=== Task's Priority Autoupdating and AutoSorting feature
==== Current Implementation

The autoupdating and autosorting mechanism resides inside `UniqueTaskList`. The `UniqueTaskList` is responsible for updating each Task’s priority level and sorting the `ObservableList<Task>` whenever a new `Task` is added. In addition, whenever a `Task` is edited, the `ObservableList<Task>` is sorted again.

===== Description of `UniqueTaskList` 's `add` method

The `add` method of the `UniqueTaskList` class is implemented as such:

[source,java]
----
public void add(Task toAdd) throws DuplicateTaskException {
    //check non null and no duplicate task
    toAdd = updatePriority(toAdd);
    internalList.add(toAdd);
    sortTasks();
}
----

The `updatePriority` method returns a new `Task` with a new `Priority` based on the current date, `AddedDate`, and `Deadline`.

The new `Priority` level will remain within the range of 0 - 9. The new `Priority` is calculated as such :

* If the current date is equal to `AddedDate`
** `Priority` remains the same.
* If the current date is past `Deadline`
** `Priority` is set to the `HIGHEST_SETTABLE_PRIORITY_LEVEL` : 9
* If the current date is before `Deadline` and not equal to `AddedDate`
** `Priority is calculated via the following formula :

[source,java]
----
priorityDifferenceFromMax = HIGHEST_SETTABLE_PRIORITY_LEVEL - currentPriority

dayDifferenceCurrentToDeadline = Duration.between(currentDate, deadline)

dayDifferenceAddedToDeadline = Duration.between(dateAdded, deadline)

priorityToIncrease = priorityDifferenceFromMax * ((dayDifferenceAddedToDeadline - dayDifferenceCurrentToDeadline) / dayDifferenceAddedToDeadline)

newPriority = currentPriority + priorityToIncrease
----

The new `Task` with its updated `Priority` will then be added to `UniqueTaskList`’s `internalList`. Following that, the `internalList` is sorted via the `sortTasks` method. The `sortTasks` method is implemented as such:

[source,java]
----
private void sortTasks() {
    internalList.sort(Task.priorityComparator());
}
----

The `sortTasks` method makes use of the `ObservableList` class’s `sort` method and `Task`’s `priorityComparator` method. The `priorityComparator` method returns a `Comparator` that sorts `Task`’s based on descending `Priority` levels. The `internalList` is sorted with respect to the comparator.

===== Scenario

Consider a `addTask` method call by the `Organizer`. The current date is 2018-03-19.

The following is a sequence diagram which represents the `Organizer` adding a Study `Task`.

.addTask(Study) method execution sequence diagram
image::OrganizerAddTaskSequenceDiagram.png[width="800"]

Suppose the `tasks` currently contains the following two `Task` s.

.`tasks` 's initial `Task` s
image::OrganizerAddTaskDiagram1.png[width="800"]

The following figure represents the "Study" `Task`.

."Study" `Task`
image::OrganizerAddTaskDiagram2.png[width="300"]

When `tasks` calls `updatePriority(Study)`, the new priority level is calculated as such :

[source,java]
----
priorityDifferenceFromMax = 9 - 0 = 9

dayDifferenceCurrentToDeadline = 14

dayDifferenceAddedToDeadline = 31

priorityToIncrease = 9 * ((31 - 14) / 31) = 4

newPriority = 0 + 4 = 4
----

A new "Study" `Task` is created and added to the `internalList`.

.`internalList` after "Study" `Task` is added
image::OrganizerAddTaskDiagram3.png[width="800"]

The `sortTasks` method is then called, which calls the `priorityCompartor` method, and uses the `Comparator` returned to sort the `Task` s. This results in the following `UniqueTaskList`.

.`internalList` after `sortTasks` is called
image::OrganizerAddTaskDiagram4.png[width="800"]

==== Design Considerations
===== Aspect : Implementation of `updatePriority`

* Alternative 1 (current choice): Add a new method `updatePriority` in UniqueTaskList’s `add`
** Pros : Convenient to update the priority during this method call; since during initialization of `Organizer`, `add` is called for every `Task` to initialize the `UniqueTaskList`.
** Cons : Possible violation of Single Responsibility Principle and Separation of Concerns as `UniqueTaskList` now updates `Task` priorities and stores `Task` s.
* Alternative 2 : Add a new class `UpdatedUniqueTaskList` which extends `UniqueTaskList`
** Pros : Removes violation of Single Responsibility Principle and Separation of Concerns in Alternative 1.
** Cons : Repeats the logic in `UniqueTaskList` while adding one method.

===== Aspect : How `updatePriority` executes

* Alternative 1 (current choice) : Return a new `Task` with new `Priority`
** Pros : Easy to implement.
** Cons : A new object is created twice during every addition, even if `Priority` is not updated; Hence slightly inefficient.
* Alternative 2 : Edit the `Priority` parameter of the `Task`
** Pros : No new objects need to be created.
** Cons : Requires major overhaul of `Task` and it’s parameters to be mutable.

===== Aspect : Scope of `updatePriority` and `sortTasks`

* Alternative 1 (current choice) : Implement within `Model`
** Pros : No need to deal with commands, and fits with the idea of automation.
** Cons : Concern of updating priorities and sorting tasks may not lie with `Model` but `Logic`.
* Alternative 2 : Implement within `Logic`
** Pros : Fits with the concern of updating priorities and sorting tasks.
** Cons : Requires development of commands and extra command calls to be automatically called upon start of application; unnecessary trouble for same feature.

// end::taskpriority[]

// tag::calendar[]
=== Calendar Feature
==== Current Implementation

The calendar feature is facilitated by the `Calendar` class, which supports the `CalendarPanel`. The `Calendar` is responsible for displaying a monthly calendar view to the users through the `CalendarPanel`. The following diagram describes the structure of the calendar system:

.UML Class Diagram for Calendar
image::CalendarComponentClassDiagram.png[width="800"]

As you can see from the diagram, `MonthView` facilitates the drawing of the calendar, while `Calendar` supports the display of the calendar onto the `CalendarPanel`. The `MonthView` interacts very closely with the corresponding FXML file, and the following diagram shows the basic layout of the calendar:

.Basic Calendar Layout
image::MonthViewLayoutDiagram.png[width="800"]

The basic calendar layout (refer to Figure 25) is reflected in the `MonthView.fxml` file, and is loaded by `MonthView`. `MonthView` uses the JavaFX layout objects extensively when drawing the calendar. An example would be the `addMonthDate` method, which adds a particular date to the exact `column` and `row` in the `taskCalendar`. The `addMonthDate` method is implemented as such:

[source,java]
----
private void addMonthDate(Text dateToPrint, int column, int row) {
    taskCalendar.add(dateToPrint, column, row);
    taskCalendar.setHalignment(dateToPrint, HPos.LEFT);
    taskCalendar.setValignment(dateToPrint, VPos.TOP)
}
----

Both the `Calendar` and `CalendarPanel` use the JavaFX `StackPane` object as a placeholder for the `MonthView`. After loading the respective FXML files, methods in the `Calendar` and `CalendarPanel` fetch the display for the `MonthView` as such:

[source,java]
----
public void getCurrentMonth(YearMonth currentYearMonth) throws IOException {
    // draws the calendar for the current month
    calendarPlaceholder.getChildren().add(monthView.getRoot());
}

private void createMainView() throws IOException {
    // fetches the calendar view
    calendarPane.getChildren().add(calendar.getRoot());
}
----

// end::calendar[]

// tag::subtask[]
=== Subtask
==== Current Implementation

Subtask feature allows user to split their tasks into multiple subtasks. This feature allows user to better
manage their task. It is implemented using `Subtask` class and `UniqueSubtaskList` class as shown by the diagram below:

.Subtask UML Class Diagram
image::SubtaskComponentDiagram.png[width="800"]

`UniqueSubtaskList` is created to ensure that no task have a duplicated subtask.

*Subtask management*

To manage the subtasks (Add, edit, etc), the task should be copied since `Task` is immutable.

==== Design Consideration
===== Aspect: Implementation of `Subtask`
* **Alternative 1 (current implementation):** Add a new class `Subtask`
** Pros: Better isolation and easier modification to `Subtask` if needed.
** Cons: Restricted the possibility of having a subtask that have subtasks.

* **Alternative 2:** Use current `Task` class
** Pros: Easier to implement and subtask will share the same properties with `Task`.
** Cons: Possibility of having a cyclic subtask (a task that also a subtask of it self) if not handled carefully.

===== Aspect: Implementation of `UniqueSubtaskList`
* **Alternative 1 (current implementation):** Use `List` to store subtasks.
** Pros: Easier to implement
** Cons: Performance issue will appear when that data is large. Since any operation in `UniqueSubtaskList` except lookup
is `O(n)`

* **Alternative 2:** Use a combination of BBST and LinkedList to store subtasks.
** Pros: Faster that the first alternative since it only took `O(log n)` to do every operation.
** Cons: Harder to implement and more robust testing is required since it is more bug prone than the first alternative.

The second alternative is planned to be implemented in the near future.

// end::subtask[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Testing]]
== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include:
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.organizer.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include:
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.organizer.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.organizer.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.organizer.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release:

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

[appendix]
== Product Scope

*Target user profile*:

* busy university students who has many tasks to keep track of, and are reasonably comfortable using CLI apps
* is taking many modules, and is part of various student organizations and activities
* prefers a digital organizer over a physical organizer
* requires help in monitoring the numerous tasks and their levels of importance
* would like assistance for the planning of tasks
* is forgetful, and requires constant reminders
* prefers desktop apps over other types
* can type fast
* prefers typing over mouse input

*Value proposition*:

Helps busy university students keep track of their tasks and priorities

*Feature contribution*:

* Agus Sentosa Hermawan
** Major : Subtasks parameter
*** Allows tasks to be split into subtasks for better management
** Minor : Toggle command
*** Allows tasks to be marked as completed
* Dominic Kenn Lim
** Major : User login
*** Allows multiple users to access their private tasks within the same machine
** Minor : Priority autosorting and autoupdate
*** Allows application to automatically manage task priority levels so that the user does not have to
* Natania Djohaari
** Major : Recurring Tasks
*** Helps users automatically create tasks that are recurring
** Minor : RemoveTag method
*** Allows application to remove a specific tag from all tasks
* Yeo Guek Ling
** Major : Calendar
*** Allows users to be able to have a more concise view of task deadlines
** Minor : Find deadline / description command
*** Allows users to be able to search the organizer for tasks even when they have forgotten the task's name

[appendix]
== User Stories

The following is a list of user stories for PrioriTask.

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the application

|`* * *` |user |add a new task |

|`* * *` |user |add a priority level to a task |keep track of the priority levels of my tasks and allow the application to order tasks by priority levels

|`* * *` |user |add a deadline to a task |keep track of the deadlines of my tasks and allow the application to help me manage my priorities according to my deadlines

|`* *` |user |add a subtask to a task |split tasks into smaller subtasks for easier management

|`* *` |user |add tags to a task |organize the tasks based on groups such as modules or projects

|`* * *` |user |add a description to a task |give a task a description that cannot be sufficiently represented by name or subtasks

|`* * *` |user |delete a task |remove a task

|`* * *` |user |delete a deadline from a task |remove a task's deadline when necessary

|`* *` |user |delete a subtask from a task |remove a subtask I no longer need

|`* *` |user |delete a tag from a task |remove a tag from a task that no longer belongs to the group

|`* *` |user |delete a description from a task|remove a description that is no longer relevant

|`* *` |user |delete all tasks |remove all tasks quickly

|`* * *` |user |edit a task's name |update the task’s name when required

|`* * *` |user |edit a task's priority level |change a task's priority level when I need to re-organize my priorities

|`* * *` |user |edit a task's deadline |change a task's deadline

|`* *` |user |edit a subtask of a task |change a subtask's name

|`* * *`|user with many uncompleted tasks |have all tasks constantly ordered according to their priority levels |know the order I should complete my tasks

|`* *` |user |edit a task's description|change a task's description

|`* * *` |user |mark a task as complete |complete the task

|`* *` |user |mark a subtask as complete |keep track of subtasks already done

|`* * *` |user with many uncompleted tasks |view all uncompleted tasks |see all tasks that need to be done, along with the deadlines and priorities

|`* * *` |user |view all details of a task |view all details of a specified task, after seeing a list of all tasks

|`* * *` |user with many tasks |view all completed tasks |see all tasks that have been completed, for past reference

|`* *` |user with many tasks |view all tasks with a specific tag |locate all tasks with a specific tag, without the need for a manual search

|`* *` |user with many tasks |view all tasks within a certain deadline |locate all tasks within a certain deadline, without the need of a manual search

|`* *`|user |view a calender showing task's deadlines|see a chronic overview of all tasks and their deadlines

|`* *` |user with many tasks |find a task by name |locate a task without the need to search through an entire list

|`* *` |user with many tasks |find a task by description|locate a task when I have forgotten it's name

|`* *` |user who is forgetful |have tasks' priority levels be automatically updated as deadline approaches |be reminded to complete tasks

|`* *` |user who is forgetful |have tasks' priority levels be automatically increased to maximum level any are still uncompleted after the deadline has passed |be reminded to complete tasks which are past the deadline

|`* *` |user |have a reminder of tasks with high priority levels |be reminded to complete tasks with high priority levels

|`* *` |user |undo an operation |revert an operation

|`* *` |user |redo an undo operation |redo an undo operation

|`* *` |user |have a task with no priority level to have it’s priority level be automatically set to the lowest priority level |have priority levels for all tasks even if I had forgotten to set the priority levels

|`*` |user |change the view of the calendar |choose to view the calendar by year, month, week, or day

|`*` |user |reorder a task's subtasks |rearrange the order of a task's subtasks when necessary

|`*` |user |recover my past data |rewrite existing data by recovering past data when necessary

|`* *`|user using the same machine as others |have my tasks privatized | avoid privacy issues

|`* *`|user using the same machine as others |create a user account |

|`* *`|user using the same machine as others |login to PrioriTask with my own account |manage my own tasks

|`* *`|user using the same machine as others |logout of PrioriTask |ensure privacy of my tasks

|`* *`|user who has a user account |retrieve my password |login to my account if I forget my password
|=======================================================================

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `Organizer` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Delete task

*MSS*

1.  User requests to list tasks
2.  Organizer shows a list of tasks
3.  User requests to delete a specific task in the list
4.  Organizer deletes the task
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. Organizer shows an error message.
+
Use case resumes at step 2.

_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 tasks without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should come with a help feature and various helper messages so that it is usable by a novice who had only have minimal CLI experience.
.  Users are expected to know how to set up the project without an installer.
.  The end product is geared towards power users, and may not be suitable for everyone.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder.
.. Double-click the jar file. +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a task

. Deleting a task while all tasks are listed

.. Prerequisites: List all tasks using the `list` command. Multiple tasks in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No task is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
